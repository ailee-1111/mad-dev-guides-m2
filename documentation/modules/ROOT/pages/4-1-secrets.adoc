= 애플리케이션 구성 외부화

== Kubernetes 애플리케이션 구성
애플리케이션이 기존 이미지를 사용하여 Kubernetes에서 실행되는 경우 애플리케이션은 기본 구성을 사용합니다. 이 작업은 테스트를 위한 것입니다. 그러나 프로덕션 환경의 경우 배포하기 전에 애플리케이션을 사용자 지정해야 할 수 있습니다.

Kubernetes에서는 JSON 및 YAML 형식의 매니페스트를 사용하여 각 애플리케이션에 대해 의도한 구성을 지정할 수 있습니다. 애플리케이션의 이름, 레이블, 이미지 소스, 스토리지, 환경 변수 등을 정의할 수 있습니다.

애플리케이션에서 파일 조합을 구성해야 하는 경우가 있습니다. 예를 들어 생성 시에는 데이터베이스 배포에 데이터베이스 및 데이터가 미리 로드되어 있어야 합니다. 일반적으로는 환경 변수, 외부 파일 또는 명령줄 인수를 사용하여 애플리케이션을 구성합니다. 애플리케이션이 실행되는 환경에서 컨테이너 이미지, 외부 파일, 환경 변수를 사용할 수 있는 경우 이 구성 외부화 프로세스를 통해 여러 환경에 걸쳐 애플리케이션을 이식할 수 있습니다.

Kubernetes는 구성 맵 및 시크릿을 사용하여 애플리케이션의 구성을 외부화하는 메커니즘을 제공합니다.

구성 맵을 사용하여 컨테이너에 구성 데이터를 삽입할 수 있습니다. 네임스페이스가 지정된 ConfigMap (구성 맵) 오브젝트는 컨테이너에 구성 데이터를 삽입하는 방법을 제공하여 컨테이너의 플랫폼 독립성을 유지하는 데 도움이 됩니다. 이러한 오브젝트는 개별 특성 등의 세분화된 정보나 전체 구성 파일 또는 JSON Blob(JSON 섹션) 등의 개괄적인 정보를 저장할 수 있습니다. 구성 맵의 정보는 보호하지 않아도 됩니다.

애플리케이션에서 중요한 정보에 액세스해야 하는 경우가 종종 있습니다. 예를 들어 백엔드 웹 애플리케이션에서는 데이터베이스를 쿼리하기 위해 데이터베이스 자격 증명에 액세스해야 합니다. Kubernetes 및 OpenShift에서는 시크릿을 사용하여 중요한 정보를 보관합니다. 예를 들어 시크릿을 사용하여 다음 유형의 중요한 정보를 저장할 수 있습니다.

* 암호

* 중요한 구성 파일

* SSH 키 또는 OAuth 토큰과 같은 외부 리소스에 대한 자격 증명

시크릿은 네임스페이스가 지정된 오브젝트이며 모든 유형의 데이터를 저장할 수 있습니다. 시크릿의 데이터는 Base64로 인코딩되며 일반 텍스트로 저장되지 않습니다. 시크릿 데이터는 암호화되지 않습니다. Base64 형식의 시크릿을 디코딩하여 원본 데이터에 액세스할 수 있습니다. 

Kubernetes 및 OpenShift는 다음 유형의 시크릿을 지원합니다.

* 불투명 시크릿: 임의의 값을 포함하고 키 이름 또는 값에 대한 규칙을 준수하도록 검증되지 않은 불투명 시크릿 저장소 키 및 값 쌍입니다.

* 서비스 계정 토큰: Kubernetes API에 인증하는 애플리케이션의 토큰 자격 증명을 저장합니다.

* 기본 인증 시크릿: 기본 인증에 필요한 자격 증명을 저장합니다. 시크릿 개체의 데이터 매개 변수에는 Base64 포맷으로 인코딩된 사용자 및 암호 키가 포함되어야 합니다.

* SSH 키: SSH 인증에 사용되는 데이터를 저장합니다.

* TLS 인증서: TLS에 사용되는 인증서 및 키를 저장합니다.

* Docker 구성 시크릿: 컨테이너 이미지 레지스트리에 액세스하기 위한 자격 증명을 저장합니다.

특정 시크릿 리소스 유형에 정보를 저장하는 경우 Kubernetes는 데이터가 시크릿 유형에 맞는지 확인합니다.





= Secrets
include::_attributes.adoc[]
:watch-terminal: Terminal 2

Secrets are an out of the box way Kubernetes provides to store sensitive data.  Most similar to config maps, these are treated with a bit of extra care under the hood in Kubernetes.

Secrets are meant to give developers a way of specifying common types of sensitive data (basic-auth credentials, image registry credentials, TLS certs, etc) without including it (insecurely) in the code (application or infrastructure) of their containerized application.  A typical generic secret that one will come across are the credentials for accessing a database.

The heart of any secret is not displayed in plain-text by default.  Instead, secret data is base64 encoded and needs to be decoded to be read.

[WARNING]
====
Like most data in the Kubernetes API, secrets are stored within the `etc` distributed data store.  Whilst access to this data is mediated by the cluster's RBAC, it should be noted that Secrets are NOT encrypted at rest within `etcd` in Kubernetes by default.  This can be enabled on generic Kubernetes by following link:https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/[these instructions^].  OpenShift makes this even easier as documented link:https://docs.openshift.com/container-platform/4.7/security/encrypting-etcd.html[here^]
====

== Prerequisites

Make sure you are in the correct namespace:

:section-k8s: resource
:set-namespace: myspace

include::partial$namespace-setup-tip.adoc[]

include::partial$set-context.adoc[]

Make sure nothing is running in your namespace:

[#no-resources-resource]
[.console-input]
[source, bash]
----
kubectl get all
----

[.console-output]
[source,bash]
----
No resources found in myspace namespace.
----

Deploy `myboot` service:

[#deploy-myboot-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl apply -f apps/kubefiles/myboot-deployment.yml
----

Deploy myboot Service:

[#service-myboot-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl apply -f apps/kubefiles/myboot-service.yml
----

In a separate terminal (hereafter referred to as *{watch-terminal}*) set up a watch on the pods: 

:section-k8s: secrets
include::partial$watching-pods-with-nodes.adoc[]

Meanwhile, in the main terminal, send a request:

:service-exposed: myboot
include::partial$env-curl.adoc[]

which should give us the by now familiar response

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Aloha from Spring Boot! 1 on myboot-7cbfbd9b89-dl2hv
----

== Creating Secrets

Previously, we used a `ConfigMap` to hold a database connection string (`user=MyUserName;password=pass:[*****]`). Instead, let's create a secret to hold this sensitive data.

The `kubectl` CLI has some support for creating generic (or `opaque`) secrets like the one we would use for a database login. 

[#create-secret-cli-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl create secret generic mysecret --from-literal=user='MyUserName' --from-literal=password='mypassword'
----

[#get-secret-cli-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get secrets
----

Which will now yield output similar to the following

[tabs]
====
Minikube::
+
--
[.console-output]
[source,bash,subs="+macros,+attributes"]
----
NAME                  TYPE                                  DATA   AGE
default-token-nxkpw   kubernetes.io/service-account-token   3      5d12h
mysecret              Opaque                                2      25s
----
--
OpenShift::
+
--
[.console-output]
[source,bash]
----
NAME                       TYPE                                  DATA   AGE
builder-dockercfg-96ml5    kubernetes.io/dockercfg               1      3d6h
builder-token-h5g82        kubernetes.io/service-account-token   4      3d6h
builder-token-vqjqz        kubernetes.io/service-account-token   4      3d6h
default-dockercfg-bsnjr    kubernetes.io/dockercfg               1      3d6h
default-token-bl77s        kubernetes.io/service-account-token   4      3d6h
default-token-vlzsl        kubernetes.io/service-account-token   4      3d6h
deployer-dockercfg-k6npn   kubernetes.io/dockercfg               1      3d6h
deployer-token-4hb78       kubernetes.io/service-account-token   4      3d6h
deployer-token-vvh6r       kubernetes.io/service-account-token   4      3d6h
mysecret                   Opaque                                2      5s
----
--
====

Because this is a `Secret` and not a `ConfigMap`, the user & password are not immediately visible:

[#describe-secret-cli-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl describe secret mysecret
----

[.console-output]
[source,bash]
----
Name:         mysecret
Namespace:    myspace
Labels:       <none>
Annotations:  <none>

Type:  Opaque

Data
====
password:  10 bytes
user:      10 bytes
----

[#get-secret-cli-yaml-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get secret mysecret -o yaml
----


[source,yaml]
----
apiVersion: v1
data:
  password: bXlwYXNzd29yZA==
  user: TXlVc2VyTmFtZQ==
kind: Secret
metadata:
  creationTimestamp: "2020-03-31T20:19:26Z"
  name: mysecret
  namespace: myspace
  resourceVersion: "4944690"
  selfLink: /api/v1/namespaces/myspace/secrets/mysecret
  uid: e8c5f12e-bd71-4d6b-8d8c-7af9ed6439f8
type: Opaque
----

Copy the value of the password field above into the echo command below to prove that it is base64 encoded

[#get-secret-cli-password-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
echo 'bXlwYXNzd29yZA==' | base64 --decode
----

[.console-output]
[source,bash]
----
mypassword
----

[TIP]
====
If pressed for time, you can run the following command instead

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
B64_PASSWORD=$(kubectl get secret mysecret -o jsonpath='{.data.password}')
echo "password:$B64_PASSWORD is decoded as $(echo $B64_PASSWORD | base64 --decode)"
----

====

And then do the same for the username

[#get-secret-cli-username-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
echo 'TXlVc2VyTmFtZQ==' | base64 --decode
----

[.console-output]
[source,bash]
----
MyUserName
----

[TIP]
====
If pressed for time, you can run the following command instead

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
B64_DATA=$(kubectl get secret mysecret -o jsonpath='{.data.user}')
echo "username:$B64_DATA is decoded as $(echo $B64_DATA | base64 --decode)"
----

====


Or get them using `kubectl`:

[#get-secret-kubectl-password-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get secret mysecret -o jsonpath='{.data.password}' | base64 --decode 
----

== Using Secrets

:quick-open-file: myboot-deployment-configuration-secret.yml

Let's take a look at a deployment, `{quick-open-file}`, that will make use of our newly created secret. 

include::partial$tip_vscode_quick_open.adoc[]

[.console-output]
[source,yaml,subs="+macros,+attributes"]
.{quick-open-file}
----
include::example$myboot-deployment-configuration-secret.yml[]
----
<.> This determines where the pod will find the secret.  It will be in a file in the `/mystuff/secretstuff` directory in the pod
<.> This defines what `mysecretvolume` should actually mount.  In this case `mysecret`, the secret we just created above.

One way to allow deployments (pods) to use secrets is to provide them via Volume Mounts:

[source, yaml]
----
        volumeMounts:          
          - name: mysecretvolume
            mountPath: /mystuff/mysecretvolume
----

Let's update our deployment to use this volume:

[#replace-myboot-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl replace -f apps/kubefiles/myboot-deployment-configuration-secret.yml
----

_Once the deployment has been updated_, exec into the newly created Pod:

[#print-secrets-volume-secrets]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
PODNAME=$(kubectl get pod -l app=myboot --field-selector pass:['status.phase!=Terminating'] -o name)
kubectl exec $PODNAME -- ls -l /mystuff/secretstuff
kubectl exec $PODNAME -- cat /mystuff/secretstuff/password
----

Results in:

[.console-output]
[source,bash]
----
total 0
lrwxrwxrwx. 1 root root 15 Jul 19 03:37 password -> ..data/password #<.>
lrwxrwxrwx. 1 root root 11 Jul 19 03:37 user -> ..data/user
mypassword #<.>
----
<.> Refer back to the secret definition.  Each field under the `.data` section of the secret has become a file in this directory that represents the mounted secret
<.> `cat` ing the value of the `password` file gives the value of the `.data.password` field in the `secret` we defined above

[TIP]
====
Alternatively, you can just run the following command to rsh into the pod and poke around

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
PODNAME=$(kubectl get pod -l app=myboot --field-selector pass:['status.phase!=Terminating'] -o name)
kubectl exec -it $PODNAME -- /bin/bash
----
====


But how would your application know to look in this directory for credentials?  Whilst it could be hardcoded in the application (or via properties) you could also provide the path via `/mystuff/mysecretvolume` to the pod via an environment variable so the application knows where to look.  

[TIP]
====
It's also possible to expose secrets directly as environment variables, but that's beyond the scope of this tutorial.
====

For more information on secrets, see https://kubernetes.io/docs/concepts/configuration/secret/[here]

== Clean Up

[.console-input]
[source,bash]
----
kubectl delete deployment myboot
kubectl delete service myboot
----



