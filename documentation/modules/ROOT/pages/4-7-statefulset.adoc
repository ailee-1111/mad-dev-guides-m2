= StatefulSets

'StatefulSet'은 관리하는 포드에 고유한 ID를 제공합니다.
`StatefulSet`은 애플리케이션이 포드 (재)스케줄링 전반에 걸쳐 고유한 네트워크 식별자 또는 영구 저장소를 요구하거나 애플리케이션이 배포 및 확장 순서에 대해 어느 정도 보장이 필요할 때 특히 유용합니다.

`StatefulSet`을 사용하는 가장 일반적인 예 중 하나는 클러스터를 시작하기 위해 각 서버의 호스트 이름을 미리 알아야 하는 기본/보조 서버(예: 데이터베이스 클러스터)를 배포해야 하는 경우입니다. 또한 확장할 때  위아래로 지정된 순서대로 수행하려는 경우(즉, 기본 노드를 먼저 시작한 다음 보조 노드를 시작하려는 경우)


[IMPORTANT]
====
'StatefulSet'에 액세스하려면 표준 Kubernetes _service_ 대신 Kubernetes _Headless Service_가 필요합니다.  이에 대해서는 아래에서 더 자세히 논의하겠습니다.
====

== Preparation



=== Namespace Setup


네임스페이스를 생성 후, 올바른 네임스페이스에 있는지 확인하세요.


[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc new-project sf-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
namespace/sf-%userid% created
----

NOTE: `oc new-project ev-%userid%` : sf-%userid%라는 새 프로젝트(네임스페이스)를 생성합니다.

[#kubectl-deploy-app]
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc project sf-%userid%
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Now using project "sf-%userid%" on server "https://172.30.0.1:443".
----

NOTE: `oc project sf-%userid%` : 현재 활성화된 컨텍스트의 기본 네임스페이스를 sf-%userid%로 변경합니다.



네임스페이스에서 아무것도 실행되고 있지 않은지 확인하세요.

[#no-resources-resource]
[.console-input]
[source, bash]
----
oc get all
----

[.console-output]
[source,bash]
----
No resources found in myspace namespace.
----






=== Watch Terminal

무슨 일이 일어나고 있는지 관찰할 수 있도록 다른 터미널을 열고 다양한 작업을 실행할 때 어떤 일이 일어나는지 `관찰`해 보겠습니다.


===Terminal#2에서 작업
--
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
watch -n 1 "oc get pods -o wide \#<.>
  | awk '{print \$1 \" \" \$2 \" \" \$3 \" \" \$5 \" \" \$7}' | column -t" #<.>
----
<.> `-o wide` 옵션을 사용하면 포드가 예약된 노드를 볼 수 있습니다. +
<.> 줄이 너무 길어지는 것을 방지하기 위해 `awk`와 `column`을 사용하여 원하는 열만 가져오고 형식을 지정합니다.

--






=== Multi-node (minikube)

클러스터가 여러 노드를 실행 중이고 외부에서 서비스에 연결할 수 있도록 특정 노드에 상태 저장 서비스를 할당해야 하는 경우 'NODE'를 상태 저장 서비스를 실행하지 않으려는 노드의 이름으로 바꾸세요.  ~에

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
NODE=devnation-02 #<.>
kubectl taint node pass:[${NODE}] app=quarkus-statefulset:NoExecute
----
<.> 이를 교체하거나 Stateful 세트를 할당하지 않으려는 클러스터의 모든 노드에 대해 반복합니다.  외부 참조:taints-affinity.adoc[Taints 및 Affinity 섹션, window=_blank]도 참조하세요.







== StatefulSet

StatefulSet은 Kubernetes `StatefulSet` 리소스를 사용하여 생성됩니다.

[source, yaml]
----
apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: quarkus-statefulset
  labels:
    app: quarkus-statefulset
spec:
  serviceName: "quarkus" # <.>
  replicas: 2
  selector:
    matchLabels:
      app: quarkus-statefulset
  template:
    metadata:
      labels:
        app: quarkus-statefulset
    spec:
      containers:
      - name: quarkus-statefulset
        image: quay.io/rhdevelopers/quarkus-demo:v1
        ports:
        - containerPort: 8080
          name: web
----

<.> `serviceName`은 이 `StatefulSet`을 관리하는 (헤드리스) 서비스의 이름입니다.  이 서비스는 StatefulSet 이전에 존재해야 하며 세트의 네트워크 ID를 담당합니다.

[#hostname-formula]
다음 "공식"을 사용하여 `StatefulSet`의 모든 구성원 Pod에 대한 호스트 이름을 예측할 수 있습니다.


****
`StatefulSet.name` + `-` + "순서형 인덱스" 
****

"서수 인덱스"는 `StatefulSet`에 의해 생성된 첫 번째 포드에 대해 `0`부터 시작하는 숫자이며 각 추가 복제본 포드에 대해 1씩 증가됩니다.  따라서 이 경우 위의 `StatefulSet`의 첫 번째 포드에 호스트 이름이 있을 것으로 예상합니다.

****
`quarkus-statefulset-0`
****

마지막으로 위에서 언급한 것처럼 트래픽을 StatefulSet의 포드로 라우팅하려면 *헤드리스 서비스*도 생성해야 합니다.

[source, yaml,subs="+quotes"]
----
apiVersion: v1
kind: Service
metadata:
  name: #quarkus# #<.>
  labels:
    app: quarkus-statefulset
spec:
  ports:
  - port: 8080
    name: web
  clusterIP: None #<.>
  selector:
    app: quarkus-statefulset
----
<.> 이는 `StatefulSet`의 `serviceName` 필드와 일치합니다.  DNS 항목을 생성하려면 일치해야 합니다.
<.> `clusterIP`를 `None`으로 설정하면 서비스가 "헤드리스"됩니다.

다음 `.yaml`을 클러스터에 적용하여 `StatefulSet`과 위에서 살펴본 해당 헤드리스 서비스를 생성합니다.


[.console-input]
[source,bash,subs="+macros,+attributes"]
----
oc apply -f apps/kubefiles/quarkus-statefulset.yaml
----

그러면 watch 터미널에 다음이 표시됩니다.

[tabs]
====
{watch-terminal}::
+
--
[.console-output]
[source,bash,subs="+quotes"]
----
NAME                     READY   STATUS    RESTARTS   AGE
#quarkus-statefulset-0#   1/1     Running   0          12s
----
--
====

Notice that the Pod name is the `serviceName` with a `-0`, as it is the first (`0` th if you will) instance.  This is as we explained <<hostname-formula,above>>

Now let's take a look at the stateful set itself

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get statefulsets
----

[.console-output]
[source,bash]
----
NAME                  READY   AGE
quarkus-statefulset   1/1     109s
----

As with `deployments` we can scale `statefulsets`

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl scale sts \#<.>
  quarkus-statefulset --replicas=3
----
<.> `sts` is the shortname of the `statefulset` api-resource

Then in the watch terminal see

[tabs]
====
{watch-terminal}::
+
--
[.console-output]
[source,bash,subs="+quotes"]
----
NAME                    READY   STATUS    RESTARTS   AGE
quarkus-statefulset-0   1/1     Running   0          95s
#quarkus-statefulset-1#   1/1     Running   0          2s
#quarkus-statefulset-2#   1/1     Running   0          1s
----
--
====

Notice that the name of the Pods continues to use <<hostname-formula,the same nomenclature that we called out above>>

Also, if you check the order of events in the Kubernetes cluster, you'll notice that the Pod name ending with `-1` is created *before* those with higher ordinal index (e.g. with suffix of `-2`).

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl get events --sort-by=.metadata.creationTimestamp
----

[.console-output]
[source,bash]
----
4m4s        Normal   SuccessfulCreate          statefulset/quarkus-statefulset   create Pod quarkus-statefulset-1 in StatefulSet quarkus-statefulset successful
4m3s        Normal   Pulled                    pod/quarkus-statefulset-1         Container image "quay.io/rhdevelopers/quarkus-demo:v1" already present on machine
4m3s        Normal   Scheduled                 pod/quarkus-statefulset-2         Successfully assigned default/quarkus-statefulset-2 to kube
4m3s        Normal   Created                   pod/quarkus-statefulset-1         Created container quarkus-statefulset
4m3s        Normal   Started                   pod/quarkus-statefulset-1         Started container quarkus-statefulset
4m3s        Normal   SuccessfulCreate          statefulset/quarkus-statefulset   create Pod quarkus-statefulset-2 in StatefulSet quarkus-statefulset successful
4m2s        Normal   Pulled                    pod/quarkus-statefulset-2         Container image "quay.io/rhdevelopers/quarkus-demo:v1" already present on machine
4m2s        Normal   Created                   pod/quarkus-statefulset-2         Created container quarkus-statefulset
4m2s        Normal   Started                   pod/quarkus-statefulset-2         Started container quarkus-statefulset
----

=== Stable Network Identities

The reason we created the *headless service* previously was to ensure that the pods of our stateful set can be found _within_ the cluster (see <<Exposing StatefulSets,Exposing StatefulSets>> for reaching services from outside the cluster).  

As each Pod is created, it gets a matching DNS subdomain, taking the form: `$(podname).$(governing service domain)`, where the governing service is defined by the `serviceName` field on the StatefulSetfootnote:[See also the official Kubernetes documentation link:https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id[here]]

We can test this by creating a pod within the cluster and doing an `nslookup` from within the cluster.  Run the following command to create a pod in the namespace in which we can run cluster local `nslookup` queries

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl run -it --restart=Never --rm --image busybox:1.28 dns-test 
----

From within the container, run the folllowing command to see if we can find a pod of our StatefulSet

[tabs]
====
Container::
+
--
[.console-input]
[source,bash,subs="+macros,+attributes"]
----
nslookup quarkus-statefulset-0.quarkus
----

This should yield the following output (though your reported IP address will vary)

[.console-output]
[source,bash,subs="+macros,+attributes,+quotes"]
----
Server:    10.96.0.10
Address 1: 10.96.0.10 kube-dns.kube-system.svc.cluster.local

Name:      quarkus-statefulset-0.quarkus
Address 1: 172.17.0.3 #quarkus-statefulset-0.quarkus.myspace.svc.cluster.local# #<.>
----
<.> Notice that the full address is `$(podname).$(governing service domain).$(namespace)`.svc.cluster.local

You can now exit the pod (causing it to be cleaned up) by issuing the following command:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
exit
----
--
====

So with the help of a headless service we can find any pod of the StatefulSet by using its internal DNS name as formulated by the StatefulSet and the headless service.

== Exposing StatefulSets

Given that our stateful set needed to use a headless service, you'll notice that no external IP is assigned that we can use to access our pods from _outside_ the cluster

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl describe svc quarkus-statefulset
----

[.console-output]
[source,bash,subs="+macros,+attributes,+quotes"]
----
Name:              quarkus-statefulset
Namespace:         myspace
Labels:            app=quarkus-statefulset
Annotations:       <none>
Selector:          app=quarkus-statefulset
Type:              ClusterIP
IP Family Policy:  SingleStack
IP Families:       IPv4
#IP:                None#
#IPs:               None#
Port:              web  8080/TCP
TargetPort:        8080/TCP
Endpoints:         172.17.0.3:8080,172.17.0.4:8080,172.17.0.5:8080
Session Affinity:  None
Events:            <none>
----

Instead, only (internal) endpoints are assigned

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl describe endpoints quarkus-statefulset
----

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
Name:         quarkus-statefulset
Namespace:    myspace
Labels:       app=quarkus-statefulset
              service.kubernetes.io/headless=
Annotations:  endpoints.kubernetes.io/last-change-trigger-time: 2021-07-20T04:45:21Z
Subsets:
  Addresses:          172.17.0.3,172.17.0.4,172.17.0.5
  NotReadyAddresses:  <none>
  Ports:
    Name  Port  Protocol
    ----  ----  --------
    web   8080  TCP

Events:  <none>
----

This kind of makes sense since the whole point of using `StatefulSets` is so that we can reference a specific pod by a predictable name instead of having them abstracted away by a normal (non-headless) `Service`.  To assist with our ability to access pods by name, kubernetes exposes a label on all `StatefulSet` pods that we can use as a selector to our service

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl describe pod quarkus-statefulset-2
----

And the abbreviated output shows our label (highlighted)

[.console-output]
[source,bash,subs="+macros,+attributes,+quotes"]
----
Name:         quarkus-statefulset-2
Namespace:    myspace
Priority:     0
Node:         devnation/192.168.49.2
Start Time:   Tue, 20 Jul 2021 04:45:04 +0000
Labels:       app=quarkus-statefulset
              controller-revision-hash=quarkus-statefulset-6bf5d59699
              #statefulset.kubernetes.io/pod-name=quarkus-statefulset-2#
Annotations:  <none>
----

:quick-open-file: quarkus-statefulset-external-svc.yaml

We can use this label as a selector for a service that targets this specific pod.  Take a look at `{quick-open-file}`: 

include::partial$tip_vscode_quick_open.adoc[]

[.console-output]
[source,yaml,subs="+macros,+attributes"]
.{quick-open-file}
----
include::example$quarkus-statefulset-external-svc.yaml[]
----
<.> Indicate that this service should be exposed via LoadBalancer
<.> Prevent excessive hops by routing traffic directly to the node
<.> A selector that leverages the label provided automatically by the Kubernetes StatefulSet functionality

Having reviewed the service we can now create it:

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl apply -f apps/kubefiles/quarkus-statefulset-external-svc.yaml
----

Meanwhile, in the main terminal, send a request:

:service-exposed: quarkus-statefulset-2
include::partial$env-curl.adoc[]

You should receive the following back

[.console-output]
[source,bash,subs="+macros,+attributes,+quotes"]
----
Supersonic Subatomic Java with Quarkus quarkus-statefulset-2:1 #<.>
----
<.> Notice the hostname of `quarkus-statefulset-2`.  This is part of why we used stateful sets in the first place, so that pods would get predictable hostnames

== Scale Down and Cleanup

Finally, if we scale down to two instances, the one that is destroyed is not randomly chosen, but the one started later (`quarkus-statefulset-2`).

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl scale sts quarkus-statefulset --replicas=2
----

[tabs]
====
{watch-terminal}::
+
--
[.console-output]
[source,bash,subs="+quotes"]
----
NAME                    READY   STATUS        RESTARTS   AGE
quarkus-statefulset-0   1/1     Running       0          9m22s
quarkus-statefulset-1   1/1     Running       0          7m49s
#quarkus-statefulset-2   0/1     Terminating   0          7m48s#
----
--
====

Beware when using stateful sets and services that this could break things.  Remember that the service we created above referenced that exact pod in the stateful set.  If you try to reach it now

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
curl pass:[${IP}:${PORT}]
----

You'll get an error (perhaps like this one)

[.console-output]
[source,bash,subs="+macros,+attributes"]
----
curl: (7) Failed to connect to 192.168.86.58 port 31834: Connection refused
----

=== Clean Up

You've now reached the end of this section.  You can clean up all aspects of the statefulset by deleting the yaml that spawned it (as well as the external service)

[.console-input]
[source,bash,subs="+macros,+attributes"]
----
kubectl delete -f apps/kubefiles/quarkus-statefulset.yaml
kubectl delete -f apps/kubefiles/quarkus-statefulset-external-svc.yaml
----
